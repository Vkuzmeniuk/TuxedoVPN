# Certificates (Let’s Encrypt / Certbot)

`ocserv` can run either:

- with **self-signed** certificates generated by the role (default), or
- with **public** certificates (recommended) from Let’s Encrypt / Certbot.

TLS mode is configured per host via `tuxedovpn_tls_mode` (recommended location: `host_vars/<host>.yml`):

```yaml
tuxedovpn_tls_mode: "selfsigned" # selfsigned | certbot
```

ACME validation method can also be set per host (recommended):

```yaml
tuxedovpn_acme_challenge: "dns" # dns | http | http_webroot
tuxedovpn_acme_dns_provider: "cloudflare"
```

You can also set this as a global default in `group_vars/all/vars.yml` and override it per host as needed.

Both `group_vars/vpn.yml` and `group_vars/mgmt/vars.yml` derive `vpn_cert_use_existing` from this flag.

This repository includes a dedicated role `roles/certbot`.
When `tuxedovpn_tls_mode: "certbot"` is enabled and the expected certificate files are missing, VPN/service roles can auto-issue certificates via this role during a normal `site.yml` run.
No separate certificate-issuing playbooks are required.

## Domains and subdomains

- VPN gateways use `vpn_domain` from `host_vars/<vpn-host>.yml` as the TLS SNI name.
- mgmt web services typically use subdomains:
  - `grafana.<base-domain>`
  - `prometheus.<base-domain>`
  - `pihole.<base-domain>`

By default the mgmt base domain is taken from `vpn_domain` (in `host_vars/<mgmt-host>.yml`), but you can override it with `mgmt_services_base_domain`.

## mgmt reverse proxy (TLS termination for internal services)

The main playbook includes an optional role `roles/mgmt-reverse-proxy` that can publish:

- `grafana.<base-domain>` → `127.0.0.1:3000`
- `prometheus.<base-domain>` → `127.0.0.1:9090`
- `pihole.<base-domain>` → `127.0.0.1:80`

Enable on mgmt:

- `group_vars/mgmt/vars.yml`: `mgmt_reverse_proxy_enable: true`

It uses the same toggle (`tuxedovpn_tls_mode`). For `certbot` mode, make sure the issued certificate covers the services' subdomains (SAN or wildcard).

## Recommended challenge type

### DNS-01 (recommended)

Use DNS-01 when:

- VPN nodes are behind an L4 proxy (HAProxy tcp/SNI passthrough) and port 80 is not routed to the node.
- You need wildcard certificates (`*.example.com`).

DNS-01 does not require opening inbound ports on the host, so UFW can stay locked down.
For auto-issuance via `site.yml` the simplest config is:

```yaml
# group_vars/all/vars.yml or host_vars/<host>.yml
tuxedovpn_acme_challenge: "dns"
tuxedovpn_acme_dns_provider: "cloudflare"
```

Example (Cloudflare token):

- Vault:
  - `vault_certbot_email`
  - `vault_certbot_cloudflare_api_token` (recommended), or `vault_certbot_dns_credentials_ini`
  - Note: don’t wrap the token in quotes; it should be a raw token string.
  - The registrar (e.g. Namecheap) does not matter: what matters is where DNS is hosted.
    For Cloudflare DNS-01, the zone must exist in Cloudflare and your domain must use Cloudflare nameservers.
  - Cloudflare API Token permissions (minimum):
    - `Zone` → `Zone` → `Read` (needed to list zones / find zone_id)
    - `Zone` → `DNS` → `Edit` (needed to create TXT records for ACME)
  - If you enable “Client IP Address Filtering” on the token, include your server public IP (otherwise DNS-01 will fail from the host).
  - If you use `vault_certbot_cloudflare_api_token`, keep `vault_certbot_dns_credentials_ini: ""` so the role generates the credentials file from the token.

### HTTP-01 (standalone, easiest with plain A-records)

Use this when:

- Your `vpn_domain` is an A-record pointing directly to the host public IP.
- Port `80/tcp` reaches the host directly (no HTTP reverse proxy/CDN in front that blocks `/.well-known/acme-challenge/`).
- You don't have DNS API credentials.

This uses Certbot in `standalone` mode (HTTP-01) on `:80`.
For safety, the role does not modify firewall rules by default.
If you choose HTTP-01, ensure `tcp/80` is reachable from the Internet (UFW allow), or explicitly enable temporary iptables rule insertion via `certbot_http01_manage_firewall: true`.

For the “closed by default” setup (recommended), set:

```yaml
certbot_http01_manage_firewall: true
```

This keeps port `80/tcp` closed normally and opens it only for the short ACME validation window during issue/renew.

### HTTP-01 (webroot + minimal nginx for ACME only)

This is a more “proxy-like” HTTP-01 flow:

- During issue/renew, Ansible (and the installed Certbot renewal hooks) temporarily run a minimal nginx listener on `80/tcp` that:
  - serves only `/.well-known/acme-challenge/`
  - redirects all other requests to `https://$host/...` (so they hit ocserv camouflage / normal TLS)
- Enable it via:

```yaml
tuxedovpn_acme_challenge: "http_webroot" # dns | http | http_webroot
```

Notes:

- Port `80/tcp` must be reachable from the Internet for validation.
- If something normally listens on port 80 (e.g. Pi-hole), it will be stopped only for the short validation window and started again afterwards.

## Issuing certificates (via `site.yml`)

### VPN gateways / ocserv

1. Set `tuxedovpn_tls_mode: "certbot"` in `host_vars/<vpn-host>.yml`.
2. Ensure `vault_certbot_email` is set (Ansible Vault).
3. Run:

```bash
ansible-playbook site.yml -l vpn -J
```

For mgmt/private ocserv on the mgmt host:

```bash
ansible-playbook site.yml -l mgmt -t private_vpn -J
```

### mgmt reverse proxy (Grafana/Prometheus/Pi-hole)

1. Enable the reverse proxy and set `mgmt_reverse_proxy_tls_mode: "certbot"`.
2. Ensure the service domains resolve to the mgmt host for ACME validation (or configure DNS-01).
3. Run:

```bash
ansible-playbook site.yml -l mgmt -t mgmt_reverse_proxy -J
```

### Selecting HTTP-01 vs DNS-01 for auto-issuance

Roles that auto-issue certificates via `roles/certbot` (ocserv and mgmt reverse proxy) default to `standalone` (HTTP-01).
To switch globally, set a single variable:

```yaml
tuxedovpn_acme_challenge: "dns" # dns | http | http_webroot
```

Optional (Cloudflare convenience autoconfig):

```yaml
tuxedovpn_acme_dns_provider: "cloudflare"
```

Or override per component/host (legacy/advanced):

- `vpn_certbot_method` / `vpn_certbot_auth_args` / `vpn_certbot_extra_args`
- `mgmt_reverse_proxy_certbot_method` / `mgmt_reverse_proxy_certbot_auth_args` / `mgmt_reverse_proxy_certbot_extra_args`

## Auto-renew

On systemd hosts the role enables `certbot.timer` so renewals are automatic.
When a certificate is renewed, Certbot runs deploy hooks installed by Ansible (to restart `ocserv` / `nginx` as configured).

## On-disk paths

VPN roles expect standard Let’s Encrypt paths:

- certificate: `/etc/letsencrypt/live/<domain>/fullchain.pem`
- private key: `/etc/letsencrypt/live/<domain>/privkey.pem`

For mgmt web services behind the built-in reverse proxy (`roles/mgmt-reverse-proxy`), the same toggle applies.
Make sure the issued certificate covers the services' subdomains (SAN or wildcard), for example:

- `grafana.<base-domain>`
- `prometheus.<base-domain>`
- `pihole.<base-domain>`

## Note about HAProxy (tcp/SNI passthrough for ocserv)

If an external HAProxy runs in `mode tcp` and routes ocserv by SNI, TLS is terminated on the VPN node.
In this setup certificates must live on the VPN nodes (DNS-01 is usually the easiest option).
