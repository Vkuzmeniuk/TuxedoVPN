---
- name: Determine effective certbot email
  ansible.builtin.set_fact:
    _certbot_email_effective: >-
      {{
        (certbot_email | default('') | string | trim)
        if (certbot_email | default('') | string | trim | length) > 0
        else (vault_certbot_email | default('') | string | trim)
      }}
  changed_when: false

- name: Ensure certbot_email is configured
  ansible.builtin.assert:
    that:
      - (_certbot_email_effective | default('') | trim | length) > 0
    fail_msg: >-
      certbot_email is empty.
      Set either:
      - certbot_email (extra vars / group_vars), or
      - vault_certbot_email (recommended in Ansible Vault).
      Detected:
      - certbot_email={{ ((certbot_email | default('') | string | trim | length) > 0) | ternary('set', 'empty/undefined') }}
      - vault_certbot_email={{ ((vault_certbot_email | default('') | string | trim | length) > 0) | ternary('set', 'empty/undefined') }}

- name: Ensure certbot_domains is provided
  ansible.builtin.assert:
    that:
      - (certbot_domains | default([]) | length) > 0
    fail_msg: "certbot_domains is empty."

- name: Validate certbot_method and auth args
  ansible.builtin.assert:
    that:
      - certbot_method in ["dns", "webroot", "standalone"]
      - (certbot_method != "dns") or ((certbot_auth_args | default([])) | length) > 0
    fail_msg: >-
      certbot_method={{ certbot_method }} requires certbot_auth_args. Example:
      ["--dns-cloudflare","--dns-cloudflare-credentials","{{ certbot_dns_credentials_path }}","--dns-cloudflare-propagation-seconds","60"]

- name: Prevent unsupported TLS-ALPN preference in standalone mode
  ansible.builtin.assert:
    that:
      - "'tls-alpn-01' not in (certbot_extra_args | default([]))"
      - "'tls-alpn' not in (certbot_extra_args | default([]))"
    fail_msg: >-
      certbot_method=standalone supports HTTP-01 only (tcp/80) with the packaged Certbot.
      Remove tls-alpn from certbot_extra_args or switch to DNS-01 (certbot_method=dns + certbot_auth_args).
  when: certbot_method == "standalone"

- name: Determine cert name
  ansible.builtin.set_fact:
    _certbot_cert_name: >-
      {{
        (certbot_cert_name | default('') | trim)
        if (certbot_cert_name | default('') | trim | length) > 0
        else (certbot_domains | first)
      }}
  changed_when: false

- name: Build certbot domain arguments
  ansible.builtin.set_fact:
    _certbot_domain_args: "{{ certbot_domains | map('regex_replace', '^(.*)$', '-d \\1') | list }}"
  changed_when: false

- name: Collect service facts (standalone)
  ansible.builtin.service_facts:
  when:
    - certbot_method == "standalone"
    - (certbot_standalone_stop_services | default([]) | length) > 0

- name: Issue/refresh certificate via certbot (with optional standalone pre-stop)
  block:
    - name: Determine iptables chain for temporary HTTP-01 allow
      ansible.builtin.shell: |
        set -euo pipefail
        if iptables -S ufw-user-input >/dev/null 2>&1; then
          echo ufw-user-input
        else
          echo INPUT
        fi
      args:
        executable: /bin/bash
      register: _certbot_http01_chain
      changed_when: false
      when:
        - certbot_method == "standalone"
        - certbot_http01_manage_firewall | default(false) | bool

    - name: Check temporary HTTP-01 allow rule (tcp/80)
      ansible.builtin.command: >-
        iptables -C {{ _certbot_http01_chain.stdout }}
        -p tcp --dport 80
        -m comment --comment tuxedovpn-certbot-http01
        -j ACCEPT
      register: _certbot_http01_rule_check
      changed_when: false
      failed_when: false
      when:
        - certbot_method == "standalone"
        - certbot_http01_manage_firewall | default(false) | bool

    - name: Insert temporary HTTP-01 allow rule (tcp/80)
      ansible.builtin.command: >-
        iptables -I {{ _certbot_http01_chain.stdout }} 1
        -p tcp --dport 80
        -m comment --comment tuxedovpn-certbot-http01
        -j ACCEPT
      register: _certbot_http01_rule_add
      changed_when: true
      when:
        - certbot_method == "standalone"
        - certbot_http01_manage_firewall | default(false) | bool
        - _certbot_http01_rule_check is defined
        - (_certbot_http01_rule_check.rc | default(1) | int) != 0

    - name: Stop services for standalone challenge (to free the port)
      ansible.builtin.service:
        name: "{{ item }}"
        state: stopped
      loop: "{{ certbot_standalone_stop_services | default([]) }}"
      register: _certbot_standalone_stop
      when:
        - certbot_method == "standalone"
        - (certbot_standalone_stop_services | default([]) | length) > 0
        - >
          (ansible_facts.services[item ~ '.service'] is defined)
          or (ansible_facts.services[item] is defined)

    - name: Compute services to restart after standalone challenge
      ansible.builtin.set_fact:
        _certbot_standalone_services_to_restart: >-
          {{
            (_certbot_standalone_stop.results | default([]))
            | selectattr('changed', 'equalto', true)
            | map(attribute='item')
            | list
          }}
      when:
        - certbot_method == "standalone"
        - (certbot_standalone_stop_services | default([]) | length) > 0
      changed_when: false

    - name: Issue/refresh certificate via certbot
      ansible.builtin.command: >-
        certbot certonly
        --non-interactive
        {% if certbot_agree_tos | bool %} --agree-tos {% endif %}
        --email {{ _certbot_email_effective | quote }}
        --cert-name {{ _certbot_cert_name | quote }}
        {% if certbot_staging | bool %} --staging {% endif %}
        {% if certbot_force_renewal | bool %} --force-renewal {% endif %}
        {% if certbot_keep_until_expiring | bool %} --keep-until-expiring {% endif %}
        {% if certbot_method == 'webroot' %} --webroot -w {{ certbot_webroot_path | quote }} {% endif %}
        {% if certbot_method == 'standalone' %} --standalone {% endif %}
        {{ (certbot_auth_args | default([])) | join(' ') }}
        {{ (certbot_extra_args | default([])) | join(' ') }}
        {{ _certbot_domain_args | join(' ') }}
      register: _certbot_issue
      changed_when: >-
        ('Congratulations!' in (_certbot_issue.stdout | default('')))
        or ('new certificate' in ((_certbot_issue.stdout | default('')) | lower))
  always:
    - name: Start services stopped for standalone challenge
      ansible.builtin.service:
        name: "{{ item }}"
        state: started
      loop: "{{ _certbot_standalone_services_to_restart | default([]) }}"
      when:
        - certbot_method == "standalone"
        - (_certbot_standalone_services_to_restart | default([]) | length) > 0

    - name: Remove temporary HTTP-01 allow rule (tcp/80)
      ansible.builtin.command: >-
        iptables -D {{ _certbot_http01_chain.stdout }}
        -p tcp --dport 80
        -m comment --comment tuxedovpn-certbot-http01
        -j ACCEPT
      changed_when: true
      failed_when: false
      when:
        - certbot_method == "standalone"
        - certbot_http01_manage_firewall | default(false) | bool
        - _certbot_http01_rule_check is defined
        - (_certbot_http01_rule_check.rc | default(0) | int) != 0
