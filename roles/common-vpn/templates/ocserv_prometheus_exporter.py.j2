#!/usr/bin/env python3
import json
import os
import subprocess
import sys
import time
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer

OCCTL_BIN = os.environ.get("OCSERV_EXPORTER_OCCTL", "{{ common_vpn_exporter_occtl_path }}")
LISTEN_HOST = os.environ.get("OCSERV_EXPORTER_LISTEN_HOST", "{{ common_vpn_exporter_listen_ip }}")
LISTEN_PORT = int(os.environ.get("OCSERV_EXPORTER_LISTEN_PORT", "{{ common_vpn_exporter_listen_port }}"))
#METRICS_PATH = os.environ.get("OCSERV_EXPORTER_METRICS_PATH", "{{ common_vpn_exporter_metrics_path }}")
SCRAPE_TIMEOUT = float(os.environ.get("OCSERV_EXPORTER_TIMEOUT", "5"))
STATIC_LABELS = {}

if "OCSERV_EXPORTER_STATIC_LABELS" in os.environ:
    try:
        STATIC_LABELS = json.loads(os.environ["OCSERV_EXPORTER_STATIC_LABELS"])
        if not isinstance(STATIC_LABELS, dict):
            STATIC_LABELS = {}
    except json.JSONDecodeError:
        STATIC_LABELS = {}


def _format_labels(extra=None):
    labels = {}
    labels.update(STATIC_LABELS)
    if extra:
        labels.update({k: str(v) for k, v in extra.items() if v is not None})
    if not labels:
        return ""

    def _escape(val):
        text = str(val)
        text = text.replace("\\", "\\\\")
        text = text.replace("\n", " ")
        text = text.replace('"', '\"')
        return text

    parts = []
    for key in sorted(labels.keys()):
        value = _escape(labels[key])
        parts.append(f'{key}="{value}"')
    return "{" + ",".join(parts) + "}"



def _load_sessions():
    try:
        result = subprocess.run(
            [OCCTL_BIN, "--json", "show", "users"],
            capture_output=True,
            text=True,
            check=False,
            timeout=SCRAPE_TIMEOUT,
        )
    except (FileNotFoundError, subprocess.TimeoutExpired) as exc:
        raise RuntimeError(f"failed to execute occtl: {exc}") from exc

    if result.returncode != 0:
        raise RuntimeError(f"occtl returned {result.returncode}: {result.stderr.strip()}")

    payload = result.stdout.strip()
    if not payload:
        return []

    try:
        data = json.loads(payload)
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"failed to parse occtl JSON: {exc}") from exc

    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        for key in ("users", "sessions", "items"):
            if key in data and isinstance(data[key], list):
                return data[key]
    return []


def _safe_get(mapping, *keys, default=0):
    value = mapping
    for key in keys:
        if isinstance(value, dict) and key in value:
            value = value[key]
        else:
            return default
    return value


def collect_metrics():
    lines = []
    now = int(time.time())
    try:
        sessions = _load_sessions()
    except RuntimeError as exc:
        lines.append(f"# ERROR {exc}")
        return "\n".join(lines) + "\n", 503

    total_sessions = len(sessions)
    lines.append("# HELP ocserv_sessions_total Number of active OpenConnect sessions")
    lines.append("# TYPE ocserv_sessions_total gauge")
    lines.append(f"ocserv_sessions_total{_format_labels()} {total_sessions}")

    lines.append("# HELP ocserv_sessions_bytes_received Current bytes received for an active session")
    lines.append("# TYPE ocserv_sessions_bytes_received gauge")
    lines.append("# HELP ocserv_sessions_bytes_sent Current bytes sent for an active session")
    lines.append("# TYPE ocserv_sessions_bytes_sent gauge")

    agg_rx = 0
    agg_tx = 0

    lines.append("# HELP ocserv_session_connected_seconds Session connected duration")
    lines.append("# TYPE ocserv_session_connected_seconds gauge")

    for session in sessions:
        username = session.get("Username") or session.get("User") or "unknown"
        remote_ip = session.get("Remote IP") or session.get("remote-host") or session.get("remote")
        vpn_ip = session.get("IPv4") or session.get("ip") or session.get("assigned_ip")
        group = session.get("GroupName") or session.get("profile")
        rx = _safe_get(session, "stats", "RX", "bytes", default=_safe_get(session, "RX", default=0))
        tx = _safe_get(session, "stats", "TX", "bytes", default=_safe_get(session, "TX", default=0))
        duration = session.get("raw_connected_at") or session.get("connected_time") or session.get("duration") or session.get("uptime") or 0

        try:
            rx_val = float(rx)
        except (TypeError, ValueError):
            rx_val = 0.0
        try:
            tx_val = float(tx)
        except (TypeError, ValueError):
            tx_val = 0.0
        try:
            dur_val = float(round(round(float(time.time())) - round(float(duration))))
        except (TypeError, ValueError):
            dur_val = 0.0

        agg_rx += rx_val
        agg_tx += tx_val

        labels = {
            "user": username,
            "remote": remote_ip or "",
            "vpn_ip": vpn_ip or "",
            "group": group or "",
        }

        lines.append(f"ocserv_sessions_bytes_received{_format_labels(labels)} {rx_val}")
        lines.append(f"ocserv_sessions_bytes_sent{_format_labels(labels)} {tx_val}")
        lines.append(f"ocserv_session_connected_seconds{_format_labels(labels)} {dur_val}")

    lines.append("# HELP ocserv_sessions_bytes_received_total Total bytes received across all active sessions")
    lines.append("# TYPE ocserv_sessions_bytes_received_total gauge")
    lines.append("# HELP ocserv_sessions_bytes_sent_total Total bytes sent across all active sessions")
    lines.append("# TYPE ocserv_sessions_bytes_sent_total gauge")
    lines.append(f"ocserv_sessions_bytes_received_total{_format_labels()} {agg_rx}")
    lines.append(f"ocserv_sessions_bytes_sent_total{_format_labels()} {agg_tx}")
    lines.append("# HELP ocserv_scrape_timestamp Exporter scrape UNIX timestamp")
    lines.append("# TYPE ocserv_scrape_timestamp gauge")
    lines.append(f"ocserv_scrape_timestamp{_format_labels()} {now}")

    return "\n".join(lines) + "\n", 200


class MetricsHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        #if self.path.rstrip("/") != METRICS_PATH.rstrip("/"):
        #    self.send_response(404)
        #    self.end_headers()
        #    self.wfile.write(b"Not Found\n")
        #    return
        body, status = collect_metrics()
        self.send_response(status)
        self.send_header("Content-Type", "text/plain; charset=utf-8")
        self.send_header("Cache-Control", "no-store")
        self.end_headers()
        self.wfile.write(body.encode("utf-8"))

    def log_message(self, fmt, *args):
        return


def main():
    server = ThreadingHTTPServer((LISTEN_HOST, LISTEN_PORT), MetricsHandler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
    finally:
        server.server_close()


if __name__ == "__main__":
    sys.exit(main())
