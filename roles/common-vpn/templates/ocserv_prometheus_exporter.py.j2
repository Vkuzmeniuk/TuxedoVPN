#!/usr/bin/env python3
import json
import os
import subprocess
import sys
import threading
import time
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer

OCCTL_BIN = os.environ.get("OCSERV_EXPORTER_OCCTL", "{{ common_vpn_exporter_occtl_path }}")
LISTEN_HOST = os.environ.get("OCSERV_EXPORTER_LISTEN_HOST", "{{ common_vpn_exporter_listen_ip }}")
LISTEN_PORT = int(os.environ.get("OCSERV_EXPORTER_LISTEN_PORT", "{{ common_vpn_exporter_listen_port }}"))
METRICS_PATH = (os.environ.get("OCSERV_EXPORTER_METRICS_PATH", "{{ common_vpn_exporter_metrics_path }}") or "/metrics").strip()
SCRAPE_TIMEOUT = float(os.environ.get("OCSERV_EXPORTER_TIMEOUT", "5"))
STATIC_LABELS = {}

if "OCSERV_EXPORTER_STATIC_LABELS" in os.environ:
    try:
        STATIC_LABELS = json.loads(os.environ["OCSERV_EXPORTER_STATIC_LABELS"])
        if not isinstance(STATIC_LABELS, dict):
            STATIC_LABELS = {}
    except json.JSONDecodeError:
        STATIC_LABELS = {}


_STATE_LOCK = threading.Lock()
_prev_sessions_by_key = None  # type: ignore[var-annotated]
_connects_total = 0
_disconnects_total = 0
_connects_by_user = {}
_disconnects_by_user = {}
_bytes_received_total = 0
_bytes_sent_total = 0


def _format_labels(extra=None):
    labels = {}
    labels.update(STATIC_LABELS)
    if extra:
        labels.update({k: str(v) for k, v in extra.items() if v is not None})
    if not labels:
        return ""

    def _escape(val):
        text = str(val)
        text = text.replace("\\", "\\\\")
        text = text.replace("\n", " ")
        text = text.replace('"', '\"')
        return text

    parts = []
    for key in sorted(labels.keys()):
        value = _escape(labels[key])
        parts.append(f'{key}="{value}"')
    return "{" + ",".join(parts) + "}"



def _load_sessions():
    try:
        result = subprocess.run(
            [OCCTL_BIN, "--json", "show", "users"],
            capture_output=True,
            text=True,
            check=False,
            timeout=SCRAPE_TIMEOUT,
        )
    except (FileNotFoundError, subprocess.TimeoutExpired) as exc:
        raise RuntimeError(f"failed to execute occtl: {exc}") from exc

    if result.returncode != 0:
        raise RuntimeError(f"occtl returned {result.returncode}: {result.stderr.strip()}")

    payload = result.stdout.strip()
    if not payload:
        return []

    try:
        data = json.loads(payload)
    except json.JSONDecodeError as exc:
        raise RuntimeError(f"failed to parse occtl JSON: {exc}") from exc

    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        for key in ("users", "sessions", "items"):
            if key in data and isinstance(data[key], list):
                return data[key]
    return []


def _safe_get(mapping, *keys, default=0):
    value = mapping
    for key in keys:
        if isinstance(value, dict) and key in value:
            value = value[key]
        else:
            return default
    return value


def _clean_label(value, default=""):
    if value is None:
        return default
    text = str(value).strip()
    if text.lower() in ("(none)", "none", "(null)", "null", "n/a", "(n/a)"):
        return default
    return text if text else default


def _extract_session_labels(session):
    username = _clean_label(session.get("Username") or session.get("User"), default="unknown")
    remote_ip = _clean_label(session.get("Remote IP") or session.get("remote-host") or session.get("remote"), default="")
    vpn_ip = _clean_label(session.get("IPv4") or session.get("ip") or session.get("assigned_ip"), default="")
    group = _clean_label(session.get("GroupName") or session.get("profile"), default="")
    return username, remote_ip, vpn_ip, group


def _session_key(session, username, remote_ip, vpn_ip, group):
    for key in (
        "SID",
        "sid",
        "SessionID",
        "Session Id",
        "Session ID",
        "session_id",
        "sessionid",
        "session-id",
    ):
        if key in session:
            value = _clean_label(session.get(key), default="")
            if value not in ("", "0"):
                return f"sid:{value}|u:{username}"
    return f"u:{username}|v:{vpn_ip}|r:{remote_ip}|g:{group}"


def _inc_counter(store, user, group, amount=1):
    if not user:
        user = "unknown"
    key = (str(user), str(group or ""))
    store[key] = int(store.get(key, 0)) + int(amount)


def _update_session_event_state(current_sessions_by_key):
    global _prev_sessions_by_key
    global _connects_total
    global _disconnects_total
    global _bytes_received_total
    global _bytes_sent_total

    with _STATE_LOCK:
        if _prev_sessions_by_key is None:
            _prev_sessions_by_key = dict(current_sessions_by_key)
            return

        prev_keys = set(_prev_sessions_by_key.keys())
        cur_keys = set(current_sessions_by_key.keys())
        for key in cur_keys - prev_keys:
            info = current_sessions_by_key.get(key) or {}
            user = info.get("user") or "unknown"
            group = info.get("group") or ""
            _connects_total += 1
            _inc_counter(_connects_by_user, user, group, 1)

        for key in prev_keys - cur_keys:
            info = _prev_sessions_by_key.get(key) or {}
            user = info.get("user") or "unknown"
            group = info.get("group") or ""
            _disconnects_total += 1
            _inc_counter(_disconnects_by_user, user, group, 1)

        for key in cur_keys & prev_keys:
            cur = current_sessions_by_key.get(key) or {}
            prev = _prev_sessions_by_key.get(key) or {}
            try:
                cur_rx = float(cur.get("rx", 0) or 0)
                prev_rx = float(prev.get("rx", 0) or 0)
                cur_tx = float(cur.get("tx", 0) or 0)
                prev_tx = float(prev.get("tx", 0) or 0)
            except (TypeError, ValueError):
                continue

            # We want monotonic per-scrape increments. If a series "resets" (new session with same labels,
            # ocserv restart, etc.), treat it as a counter reset and use current value as the increment.
            delta_rx = cur_rx - prev_rx
            if delta_rx < 0:
                delta_rx = cur_rx
            delta_tx = cur_tx - prev_tx
            if delta_tx < 0:
                delta_tx = cur_tx

            if delta_rx > 0:
                _bytes_received_total += int(delta_rx)
            if delta_tx > 0:
                _bytes_sent_total += int(delta_tx)

        _prev_sessions_by_key = dict(current_sessions_by_key)


def collect_metrics():
    lines = []
    now = int(time.time())
    try:
        sessions = _load_sessions()
    except RuntimeError as exc:
        lines.append(f"# ERROR {exc}")
        return "\n".join(lines) + "\n", 503

    total_sessions = len(sessions)
    lines.append("# HELP ocserv_sessions_total Number of active OpenConnect sessions")
    lines.append("# TYPE ocserv_sessions_total gauge")
    lines.append(f"ocserv_sessions_total{_format_labels()} {total_sessions}")

    lines.append("# HELP ocserv_sessions_bytes_received Current bytes received for an active session")
    lines.append("# TYPE ocserv_sessions_bytes_received gauge")
    lines.append("# HELP ocserv_sessions_bytes_sent Current bytes sent for an active session")
    lines.append("# TYPE ocserv_sessions_bytes_sent gauge")

    agg_rx = 0
    agg_tx = 0

    lines.append("# HELP ocserv_session_connected_seconds Session connected duration")
    lines.append("# TYPE ocserv_session_connected_seconds gauge")

    current_sessions_by_key = {}
    session_key_collisions = 0
    for session in sessions:
        username, remote_ip, vpn_ip, group = _extract_session_labels(session)
        rx = _safe_get(session, "stats", "RX", "bytes", default=_safe_get(session, "RX", default=0))
        tx = _safe_get(session, "stats", "TX", "bytes", default=_safe_get(session, "TX", default=0))
        duration = session.get("raw_connected_at") or session.get("connected_time") or session.get("duration") or session.get("uptime") or 0

        try:
            rx_val = float(rx)
        except (TypeError, ValueError):
            rx_val = 0.0
        try:
            tx_val = float(tx)
        except (TypeError, ValueError):
            tx_val = 0.0
        try:
            dur_val = float(round(round(float(time.time())) - round(float(duration))))
        except (TypeError, ValueError):
            dur_val = 0.0

        agg_rx += rx_val
        agg_tx += tx_val

        key = _session_key(session, username, remote_ip, vpn_ip, group)
        if key in current_sessions_by_key:
            session_key_collisions += 1
        current_sessions_by_key[key] = {
            "user": username,
            "group": group or "",
            "rx": rx_val,
            "tx": tx_val,
        }

        labels = {
            "user": username,
            "remote": remote_ip or "",
            "vpn_ip": vpn_ip or "",
            "group": group or "",
        }

        lines.append(f"ocserv_sessions_bytes_received{_format_labels(labels)} {rx_val}")
        lines.append(f"ocserv_sessions_bytes_sent{_format_labels(labels)} {tx_val}")
        lines.append(f"ocserv_session_connected_seconds{_format_labels(labels)} {dur_val}")

    _update_session_event_state(current_sessions_by_key)

    lines.append("# HELP ocserv_sessions_bytes_received_active_sum Sum of RX bytes across active sessions (snapshot)")
    lines.append("# TYPE ocserv_sessions_bytes_received_active_sum gauge")
    lines.append("# HELP ocserv_sessions_bytes_sent_active_sum Sum of TX bytes across active sessions (snapshot)")
    lines.append("# TYPE ocserv_sessions_bytes_sent_active_sum gauge")
    lines.append(f"ocserv_sessions_bytes_received_active_sum{_format_labels()} {agg_rx}")
    lines.append(f"ocserv_sessions_bytes_sent_active_sum{_format_labels()} {agg_tx}")

    lines.append("# HELP ocserv_exporter_session_key_collisions Number of session-key collisions in the latest scrape")
    lines.append("# TYPE ocserv_exporter_session_key_collisions gauge")
    lines.append(f"ocserv_exporter_session_key_collisions{_format_labels()} {int(session_key_collisions)}")
    lines.append("# HELP ocserv_exporter_session_keys_total Number of unique session keys in the latest scrape")
    lines.append("# TYPE ocserv_exporter_session_keys_total gauge")
    lines.append(f"ocserv_exporter_session_keys_total{_format_labels()} {int(len(current_sessions_by_key))}")

    with _STATE_LOCK:
        bytes_received_total = int(_bytes_received_total)
        bytes_sent_total = int(_bytes_sent_total)
        connects_total = int(_connects_total)
        disconnects_total = int(_disconnects_total)
        connects_by_user = list(sorted(_connects_by_user.items()))
        disconnects_by_user = list(sorted(_disconnects_by_user.items()))

    lines.append("# HELP ocserv_sessions_bytes_received_total Cumulative bytes received across all sessions observed by exporter")
    lines.append("# TYPE ocserv_sessions_bytes_received_total counter")
    lines.append("# HELP ocserv_sessions_bytes_sent_total Cumulative bytes sent across all sessions observed by exporter")
    lines.append("# TYPE ocserv_sessions_bytes_sent_total counter")
    lines.append(f"ocserv_sessions_bytes_received_total{_format_labels()} {bytes_received_total}")
    lines.append(f"ocserv_sessions_bytes_sent_total{_format_labels()} {bytes_sent_total}")

    lines.append("# HELP ocserv_sessions_connects_total Total session connect events observed by exporter")
    lines.append("# TYPE ocserv_sessions_connects_total counter")
    lines.append("# HELP ocserv_sessions_disconnects_total Total session disconnect events observed by exporter")
    lines.append("# TYPE ocserv_sessions_disconnects_total counter")
    lines.append(f"ocserv_sessions_connects_total{_format_labels()} {connects_total}")
    lines.append(f"ocserv_sessions_disconnects_total{_format_labels()} {disconnects_total}")

    lines.append("# HELP ocserv_session_connects_total Session connect events by user/group observed by exporter")
    lines.append("# TYPE ocserv_session_connects_total counter")
    lines.append("# HELP ocserv_session_disconnects_total Session disconnect events by user/group observed by exporter")
    lines.append("# TYPE ocserv_session_disconnects_total counter")
    for (user, group), value in connects_by_user:
        lines.append(f"ocserv_session_connects_total{_format_labels({'user': user, 'group': group})} {int(value)}")
    for (user, group), value in disconnects_by_user:
        lines.append(f"ocserv_session_disconnects_total{_format_labels({'user': user, 'group': group})} {int(value)}")

    lines.append("# HELP ocserv_scrape_timestamp Exporter scrape UNIX timestamp")
    lines.append("# TYPE ocserv_scrape_timestamp gauge")
    lines.append(f"ocserv_scrape_timestamp{_format_labels()} {now}")

    return "\n".join(lines) + "\n", 200


class MetricsHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        request_path = (self.path or "/").split("?", 1)[0]
        if request_path.rstrip("/") != METRICS_PATH.rstrip("/"):
            self.send_response(404)
            self.end_headers()
            self.wfile.write(b"Not Found\n")
            return
        body, status = collect_metrics()
        self.send_response(status)
        self.send_header("Content-Type", "text/plain; charset=utf-8")
        self.send_header("Cache-Control", "no-store")
        self.end_headers()
        self.wfile.write(body.encode("utf-8"))

    def log_message(self, fmt, *args):
        return


def main():
    server = ThreadingHTTPServer((LISTEN_HOST, LISTEN_PORT), MetricsHandler)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
    finally:
        server.server_close()


if __name__ == "__main__":
    sys.exit(main())
